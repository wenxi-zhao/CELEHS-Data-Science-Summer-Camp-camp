{
  "version": 3,
  "sources": ["../../../../escape-string-regexp/index.js", "../../../../mdast-util-find-and-replace/lib/index.js"],
  "sourcesContent": ["export default function escapeStringRegexp(string) {\r\n\tif (typeof string !== 'string') {\r\n\t\tthrow new TypeError('Expected a string');\r\n\t}\r\n\r\n\t// Escape characters with special meaning either inside or outside character sets.\r\n\t// Use a simple backslash escape when it’s always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.\r\n\treturn string\r\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\r\n\t\t.replace(/-/g, '\\\\x2d');\r\n}\r\n", "/**\r\n * @typedef {import('mdast').Nodes} Nodes\r\n * @typedef {import('mdast').Parents} Parents\r\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\r\n * @typedef {import('mdast').Root} Root\r\n * @typedef {import('mdast').Text} Text\r\n * @typedef {import('unist-util-visit-parents').Test} Test\r\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\r\n */\r\n\r\n/**\r\n * @typedef RegExpMatchObject\r\n *   Info on the match.\r\n * @property {number} index\r\n *   The index of the search at which the result was found.\r\n * @property {string} input\r\n *   A copy of the search string in the text node.\r\n * @property {[...Array<Parents>, Text]} stack\r\n *   All ancestors of the text node, where the last node is the text itself.\r\n *\r\n * @typedef {RegExp | string} Find\r\n *   Pattern to find.\r\n *\r\n *   Strings are escaped and then turned into global expressions.\r\n *\r\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\r\n *   Several find and replaces, in array form.\r\n *\r\n * @typedef {[Find, Replace?]} FindAndReplaceTuple\r\n *   Find and replace in tuple form.\r\n *\r\n * @typedef {ReplaceFunction | string | null | undefined} Replace\r\n *   Thing to replace with.\r\n *\r\n * @callback ReplaceFunction\r\n *   Callback called when a search matches.\r\n * @param {...any} parameters\r\n *   The parameters are the result of corresponding search expression:\r\n *\r\n *   * `value` (`string`) — whole match\r\n *   * `...capture` (`Array<string>`) — matches from regex capture groups\r\n *   * `match` (`RegExpMatchObject`) — info on the match\r\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | null | undefined}\r\n *   Thing to replace with.\r\n *\r\n *   * when `null`, `undefined`, `''`, remove the match\r\n *   * …or when `false`, do not replace at all\r\n *   * …or when `string`, replace with a text node of that value\r\n *   * …or when `Node` or `Array<Node>`, replace with those nodes\r\n *\r\n * @typedef {[RegExp, ReplaceFunction]} Pair\r\n *   Normalized find and replace.\r\n *\r\n * @typedef {Array<Pair>} Pairs\r\n *   All find and replaced.\r\n *\r\n * @typedef Options\r\n *   Configuration.\r\n * @property {Test | null | undefined} [ignore]\r\n *   Test for which nodes to ignore (optional).\r\n */\r\n\r\nimport escape from 'escape-string-regexp'\r\nimport {visitParents} from 'unist-util-visit-parents'\r\nimport {convert} from 'unist-util-is'\r\n\r\n/**\r\n * Find patterns in a tree and replace them.\r\n *\r\n * The algorithm searches the tree in *preorder* for complete values in `Text`\r\n * nodes.\r\n * Partial matches are not supported.\r\n *\r\n * @param {Nodes} tree\r\n *   Tree to change.\r\n * @param {FindAndReplaceList | FindAndReplaceTuple} list\r\n *   Patterns to find.\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration (when `find` is not `Find`).\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nexport function findAndReplace(tree, list, options) {\r\n  const settings = options || {}\r\n  const ignored = convert(settings.ignore || [])\r\n  const pairs = toPairs(list)\r\n  let pairIndex = -1\r\n\r\n  while (++pairIndex < pairs.length) {\r\n    visitParents(tree, 'text', visitor)\r\n  }\r\n\r\n  /** @type {import('unist-util-visit-parents').BuildVisitor<Root, 'text'>} */\r\n  function visitor(node, parents) {\r\n    let index = -1\r\n    /** @type {Parents | undefined} */\r\n    let grandparent\r\n\r\n    while (++index < parents.length) {\r\n      const parent = parents[index]\r\n      /** @type {Array<Nodes> | undefined} */\r\n      const siblings = grandparent ? grandparent.children : undefined\r\n\r\n      if (\r\n        ignored(\r\n          parent,\r\n          siblings ? siblings.indexOf(parent) : undefined,\r\n          grandparent\r\n        )\r\n      ) {\r\n        return\r\n      }\r\n\r\n      grandparent = parent\r\n    }\r\n\r\n    if (grandparent) {\r\n      return handler(node, parents)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle a text node which is not in an ignored parent.\r\n   *\r\n   * @param {Text} node\r\n   *   Text node.\r\n   * @param {Array<Parents>} parents\r\n   *   Parents.\r\n   * @returns {VisitorResult}\r\n   *   Result.\r\n   */\r\n  function handler(node, parents) {\r\n    const parent = parents[parents.length - 1]\r\n    const find = pairs[pairIndex][0]\r\n    const replace = pairs[pairIndex][1]\r\n    let start = 0\r\n    /** @type {Array<Nodes>} */\r\n    const siblings = parent.children\r\n    const index = siblings.indexOf(node)\r\n    let change = false\r\n    /** @type {Array<PhrasingContent>} */\r\n    let nodes = []\r\n\r\n    find.lastIndex = 0\r\n\r\n    let match = find.exec(node.value)\r\n\r\n    while (match) {\r\n      const position = match.index\r\n      /** @type {RegExpMatchObject} */\r\n      const matchObject = {\r\n        index: match.index,\r\n        input: match.input,\r\n        stack: [...parents, node]\r\n      }\r\n      let value = replace(...match, matchObject)\r\n\r\n      if (typeof value === 'string') {\r\n        value = value.length > 0 ? {type: 'text', value} : undefined\r\n      }\r\n\r\n      // It wasn’t a match after all.\r\n      if (value === false) {\r\n        // False acts as if there was no match.\r\n        // So we need to reset `lastIndex`, which currently being at the end of\r\n        // the current match, to the beginning.\r\n        find.lastIndex = position + 1\r\n      } else {\r\n        if (start !== position) {\r\n          nodes.push({\r\n            type: 'text',\r\n            value: node.value.slice(start, position)\r\n          })\r\n        }\r\n\r\n        if (Array.isArray(value)) {\r\n          nodes.push(...value)\r\n        } else if (value) {\r\n          nodes.push(value)\r\n        }\r\n\r\n        start = position + match[0].length\r\n        change = true\r\n      }\r\n\r\n      if (!find.global) {\r\n        break\r\n      }\r\n\r\n      match = find.exec(node.value)\r\n    }\r\n\r\n    if (change) {\r\n      if (start < node.value.length) {\r\n        nodes.push({type: 'text', value: node.value.slice(start)})\r\n      }\r\n\r\n      parent.children.splice(index, 1, ...nodes)\r\n    } else {\r\n      nodes = [node]\r\n    }\r\n\r\n    return index + nodes.length\r\n  }\r\n}\r\n\r\n/**\r\n * Turn a tuple or a list of tuples into pairs.\r\n *\r\n * @param {FindAndReplaceList | FindAndReplaceTuple} tupleOrList\r\n *   Schema.\r\n * @returns {Pairs}\r\n *   Clean pairs.\r\n */\r\nfunction toPairs(tupleOrList) {\r\n  /** @type {Pairs} */\r\n  const result = []\r\n\r\n  if (!Array.isArray(tupleOrList)) {\r\n    throw new TypeError('Expected find and replace tuple or list of tuples')\r\n  }\r\n\r\n  /** @type {FindAndReplaceList} */\r\n  // @ts-expect-error: correct.\r\n  const list =\r\n    !tupleOrList[0] || Array.isArray(tupleOrList[0])\r\n      ? tupleOrList\r\n      : [tupleOrList]\r\n\r\n  let index = -1\r\n\r\n  while (++index < list.length) {\r\n    const tuple = list[index]\r\n    result.push([toExpression(tuple[0]), toFunction(tuple[1])])\r\n  }\r\n\r\n  return result\r\n}\r\n\r\n/**\r\n * Turn a find into an expression.\r\n *\r\n * @param {Find} find\r\n *   Find.\r\n * @returns {RegExp}\r\n *   Expression.\r\n */\r\nfunction toExpression(find) {\r\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\r\n}\r\n\r\n/**\r\n * Turn a replace into a function.\r\n *\r\n * @param {Replace} replace\r\n *   Replace.\r\n * @returns {ReplaceFunction}\r\n *   Function.\r\n */\r\nfunction toFunction(replace) {\r\n  return typeof replace === 'function'\r\n    ? replace\r\n    : function () {\r\n        return replace\r\n      }\r\n}\r\n"],
  "mappings": ";;;;;;AAAe,SAAR,mBAAoC,QAAQ;AAClD,MAAI,OAAO,WAAW,UAAU;AAC/B,UAAM,IAAI,UAAU,mBAAmB;AAAA,EACxC;AAIA,SAAO,OACL,QAAQ,uBAAuB,MAAM,EACrC,QAAQ,MAAM,OAAO;AACxB;;;ACwEO,SAAS,eAAe,MAAM,MAAM,SAAS;AAClD,QAAM,WAAW,WAAW,CAAC;AAC7B,QAAM,UAAU,QAAQ,SAAS,UAAU,CAAC,CAAC;AAC7C,QAAM,QAAQ,QAAQ,IAAI;AAC1B,MAAI,YAAY;AAEhB,SAAO,EAAE,YAAY,MAAM,QAAQ;AACjC,iBAAa,MAAM,QAAQ,OAAO;AAAA,EACpC;AAGA,WAAS,QAAQ,MAAM,SAAS;AAC9B,QAAI,QAAQ;AAEZ,QAAI;AAEJ,WAAO,EAAE,QAAQ,QAAQ,QAAQ;AAC/B,YAAM,SAAS,QAAQ,KAAK;AAE5B,YAAM,WAAW,cAAc,YAAY,WAAW;AAEtD,UACE;AAAA,QACE;AAAA,QACA,WAAW,SAAS,QAAQ,MAAM,IAAI;AAAA,QACtC;AAAA,MACF,GACA;AACA;AAAA,MACF;AAEA,oBAAc;AAAA,IAChB;AAEA,QAAI,aAAa;AACf,aAAO,QAAQ,MAAM,OAAO;AAAA,IAC9B;AAAA,EACF;AAYA,WAAS,QAAQ,MAAM,SAAS;AAC9B,UAAM,SAAS,QAAQ,QAAQ,SAAS,CAAC;AACzC,UAAM,OAAO,MAAM,SAAS,EAAE,CAAC;AAC/B,UAAM,UAAU,MAAM,SAAS,EAAE,CAAC;AAClC,QAAI,QAAQ;AAEZ,UAAM,WAAW,OAAO;AACxB,UAAM,QAAQ,SAAS,QAAQ,IAAI;AACnC,QAAI,SAAS;AAEb,QAAI,QAAQ,CAAC;AAEb,SAAK,YAAY;AAEjB,QAAI,QAAQ,KAAK,KAAK,KAAK,KAAK;AAEhC,WAAO,OAAO;AACZ,YAAM,WAAW,MAAM;AAEvB,YAAM,cAAc;AAAA,QAClB,OAAO,MAAM;AAAA,QACb,OAAO,MAAM;AAAA,QACb,OAAO,CAAC,GAAG,SAAS,IAAI;AAAA,MAC1B;AACA,UAAI,QAAQ,QAAQ,GAAG,OAAO,WAAW;AAEzC,UAAI,OAAO,UAAU,UAAU;AAC7B,gBAAQ,MAAM,SAAS,IAAI,EAAC,MAAM,QAAQ,MAAK,IAAI;AAAA,MACrD;AAGA,UAAI,UAAU,OAAO;AAInB,aAAK,YAAY,WAAW;AAAA,MAC9B,OAAO;AACL,YAAI,UAAU,UAAU;AACtB,gBAAM,KAAK;AAAA,YACT,MAAM;AAAA,YACN,OAAO,KAAK,MAAM,MAAM,OAAO,QAAQ;AAAA,UACzC,CAAC;AAAA,QACH;AAEA,YAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,gBAAM,KAAK,GAAG,KAAK;AAAA,QACrB,WAAW,OAAO;AAChB,gBAAM,KAAK,KAAK;AAAA,QAClB;AAEA,gBAAQ,WAAW,MAAM,CAAC,EAAE;AAC5B,iBAAS;AAAA,MACX;AAEA,UAAI,CAAC,KAAK,QAAQ;AAChB;AAAA,MACF;AAEA,cAAQ,KAAK,KAAK,KAAK,KAAK;AAAA,IAC9B;AAEA,QAAI,QAAQ;AACV,UAAI,QAAQ,KAAK,MAAM,QAAQ;AAC7B,cAAM,KAAK,EAAC,MAAM,QAAQ,OAAO,KAAK,MAAM,MAAM,KAAK,EAAC,CAAC;AAAA,MAC3D;AAEA,aAAO,SAAS,OAAO,OAAO,GAAG,GAAG,KAAK;AAAA,IAC3C,OAAO;AACL,cAAQ,CAAC,IAAI;AAAA,IACf;AAEA,WAAO,QAAQ,MAAM;AAAA,EACvB;AACF;AAUA,SAAS,QAAQ,aAAa;AAE5B,QAAM,SAAS,CAAC;AAEhB,MAAI,CAAC,MAAM,QAAQ,WAAW,GAAG;AAC/B,UAAM,IAAI,UAAU,mDAAmD;AAAA,EACzE;AAIA,QAAM,OACJ,CAAC,YAAY,CAAC,KAAK,MAAM,QAAQ,YAAY,CAAC,CAAC,IAC3C,cACA,CAAC,WAAW;AAElB,MAAI,QAAQ;AAEZ,SAAO,EAAE,QAAQ,KAAK,QAAQ;AAC5B,UAAM,QAAQ,KAAK,KAAK;AACxB,WAAO,KAAK,CAAC,aAAa,MAAM,CAAC,CAAC,GAAG,WAAW,MAAM,CAAC,CAAC,CAAC,CAAC;AAAA,EAC5D;AAEA,SAAO;AACT;AAUA,SAAS,aAAa,MAAM;AAC1B,SAAO,OAAO,SAAS,WAAW,IAAI,OAAO,mBAAO,IAAI,GAAG,GAAG,IAAI;AACpE;AAUA,SAAS,WAAW,SAAS;AAC3B,SAAO,OAAO,YAAY,aACtB,UACA,WAAY;AACV,WAAO;AAAA,EACT;AACN;",
  "names": []
}
